# FreeCAD macro: generate puck-shaped part with flats, radial blind holes, chamfers (facets), and notches
# Usage: run this as a macro inside FreeCAD (Macro -> Macros... -> Create, paste and Run)
# Fix: ensure flat-cut boxes lie on the *outside* of the cutting plane so subtracting them removes the lateral chips
# (leaving the main puck body). This is done by placing the box so its max-local-Y face sits on the plane
# when the box's local-Y axis points inward; equivalently we shift the local origin by +n*box_thickness when
# local-Y points inward, so the box occupies the outside region.

import FreeCAD
import Part
from FreeCAD import Base
import math

# Ensure there is an active document
DOC = FreeCAD.ActiveDocument
if DOC is None:
    DOC = FreeCAD.newDocument("PuckDoc")

# -------------------- PARAMETERS (edit these as needed) --------------------
outer_diameter = 303.0
height = 50.0
radius = outer_diameter / 2.0

# Flats (three) - distances and angles (degrees)
flat_distance_from_center = 148.0
flat_angles_deg = [90, 210, 330]

# Blind holes (from generatrix towards center)
hole_diameter = 10.0
hole_depth = 15.0
hole_angles_deg = [30, 150, 270]

# Facet (approximation using fillet)
facet_leg = 2.0

# Notches (right-angled dents)
notch_angles = [0, 180, 270]
notch_depth = 1.0
# NOTE: to make the hypotenuse tangent and the triangle right-angled with the right angle at
# the inner vertex, the tangential opening (hypotenuse length) must be 2*notch_depth.
# That yields legs length = sqrt(2)*notch_depth.
notch_tangential_opening = 2.0 * notch_depth

# Margins for cutting solids so they are definitely big enough
tangential_margin = 50.0
radial_thickness = radius + 50.0
z_margin = 10.0

# -------------------- BUILD BASE CYLINDER --------------------
base_cyl = Part.makeCylinder(radius, height, Base.Vector(0, 0, 0), Base.Vector(0, 0, 1))
result = base_cyl

# ---------------- Facets (top & bottom) - approximate conical chamfer for curved parts ----------------
# Top chamfer: create a conical frustum that spans from z=height-facet_leg..height with radii R-facet_leg .. R
cone_top = Part.makeCone(radius, radius - facet_leg*10, facet_leg*10)
cutter_top = Part.makeCylinder(radius, facet_leg*10)
cutter_top = cutter_top.cut(cone_top)
cutter_top.translate(Base.Vector(0, 0, height - facet_leg))
result = result.cut(cutter_top)

# Bottom chamfer: mirror for bottom
cutter_bot = cutter_top.mirror(Base.Vector(0, 0, facet_leg/2), Base.Vector(0, 0, 1))
result = result.cut(cutter_bot)

#Part.show(cutter_bot, "CutterTop")

# Function to make a bevel cutter box for one flat, bottom or top
def make_bevel_box(theta_deg, zpos):
    theta = math.radians(theta_deg)
    n = Base.Vector(math.cos(theta), math.sin(theta), 0)   # radial
    t = Base.Vector(-math.sin(theta), math.cos(theta), 0)  # tangential
    
    # Box dimensions: wide enough along tangent, deep enough radially
    box_w = 40.0   # tangent length
    box_d = 80.0   # radial length
    box_h = facet_leg * 2.0
    
    if zpos < height/2 :
        dir = FreeCAD.Vector(1, 0, -1)
        pos = FreeCAD.Vector(flat_distance_from_center, -box_d/2, zpos + facet_leg)
    else:
        dir = FreeCAD.Vector(1, 0, 1)
        pos = FreeCAD.Vector(flat_distance_from_center - facet_leg, -box_d/2, zpos)
    box = Part.makeBox(box_w, box_d, box_h, pos, dir)
    
    box.rotate(Base.Vector(0,0,0), Base.Vector(0,0,1), theta_deg)
    return box

# -------------------- CREATE FLAT CUTS (FIXED: cut the outside) --------------------
# Strategy for each flat at angle theta:
# - Define unit radial vector n = (cos, sin)
# - Define tangential unit vector t = (-sin, cos)
# - Make a large box whose local Y axis (before rotation) will be mapped to -n (inward)
# - Place the box so that its local Y = box_thickness maps to the plane n . P = flat_distance_from_center
#   (i.e. the box occupies the outside region beyond the plane). This avoids removing the puck core.

cut_shapes = []
box_height = height + 2.0 * z_margin
box_width = 2.0 * radius + tangential_margin  # extent along tangential direction (X local)
box_thickness = radial_thickness  # extent along local Y (will point inward with chosen rotation)

for theta_deg in flat_angles_deg:
    theta = math.radians(theta_deg)
    nx = math.cos(theta)
    ny = math.sin(theta)
    # tangential direction (local X in global coords)
    tx = -math.sin(theta)
    ty = math.cos(theta)
    # choose rotation so that local X -> tangential, local Y -> -radial (inward)
    rot_angle = theta_deg + 90.0
    rot = FreeCAD.Rotation(Base.Vector(0, 0, 1), rot_angle)

    # Create the box in local coordinates: spans x:[0,box_width], y:[0,box_thickness], z:[0,box_height]
    box = Part.makeBox(box_width, box_thickness, box_height)

    # We want the global position of local point (0, box_thickness, 0) to be on the cutting plane
    # at Pcenter = n * flat_distance_from_center. Therefore the local-origin in global coords is:
    # origin_global = Pcenter - Rot * Vector(0, box_thickness, 0)  = Pcenter - (localY_global * box_thickness)
    Pcenter_x = nx * flat_distance_from_center
    Pcenter_y = ny * flat_distance_from_center
    # localY_global = Rot * (0,1,0) = direction of local Y in global coords (this equals -n for our rot)
    # but rather than computing it explicitly, we can use n (nx,ny) and the known sign: Rot maps (0,1,0) -> -n.
    # So origin_global = Pcenter - (-n) * box_thickness = Pcenter + n * box_thickness
    origin_x = Pcenter_x - (box_width / 2.0) * tx + nx * box_thickness
    origin_y = Pcenter_y - (box_width / 2.0) * ty + ny * box_thickness
    origin_z = -z_margin

    placement = FreeCAD.Placement(Base.Vector(origin_x, origin_y, origin_z), rot)
    box.Placement = placement

    cut_shapes.append(box)

# Subtract flats
for i, shp in enumerate(cut_shapes):
    try:
        result = result.cut(shp)
    except Exception as e:
        FreeCAD.Console.PrintError(f"Failed to subtract flat {i} at shape: {e}")

# --- Cut bevels for all 3 flats ---
for theta in flat_angles_deg:
    # bottom bevel
    btm_box = make_bevel_box(theta, 0)
    result = result.cut(btm_box)
        
    # top bevel (mirror by shifting z)
    top_box = make_bevel_box(theta, height)
    result = result.cut(top_box)

# -------------------- RADIAL BLIND HOLES --------------------
for ang in hole_angles_deg:
    a = math.radians(ang)
    ux = math.cos(a)
    uy = math.sin(a)
    # start point at the nominal outer cylinder surface, at mid-height
    start = Base.Vector(ux * radius, uy * radius, height / 2.0)
    direction = Base.Vector(-ux, -uy, 0)  # toward center
    # Part.makeCylinder accepts a direction vector; height is hole_depth
    hole = Part.makeCylinder(hole_diameter / 2.0, hole_depth, start, direction)
    try:
        result = result.cut(hole)
    except Exception as e:
        FreeCAD.Console.PrintError(f"Failed to subtract hole at {ang} deg: {e}")

# --- Notches (triangular prisms) ---
for ang_deg in notch_angles:
    ang = math.radians(ang_deg)
    n = Base.Vector(math.cos(ang), math.sin(ang), 0) # radial outward
    t = Base.Vector(-math.sin(ang), math.cos(ang), 0) # tangential

    # Triangle vertices in global coords (center at origin): H1, H2, V
    half_w = notch_tangential_opening / 2.0
    H1 = n * radius + t * (-half_w)
    H2 = n * radius + t * (half_w)
    V = n * (radius - notch_depth)

    wire = Part.makePolygon([H1, V, H2, H1])
    face = Part.Face(wire)
    prism = face.extrude(Base.Vector(0, 0, height))
    result = result.cut(prism)

# -------------------- FINALIZE PART --------------------
final_obj = DOC.addObject("Part::Feature", "Puck")
final_obj.Shape = result

# Note: the above cone-based chamfer produces an all-around 45° bevel on the curved surface.
# For flats: if you need the facets only along flats' top/bottom edges (and not on the curved areas),
# I can replace the cone-based step with planar chamfers located only at the flat angles — say so and
# I will update.


DOC.recompute()
FreeCAD.Console.PrintMessage("Puck generation completed — flats now remove outside chips, main body preserved.")
