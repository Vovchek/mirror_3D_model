import FreeCAD, Part, math
from FreeCAD import Base

# Define parameters
c = 1/773.44
k = -1.0504
D = 276.41
ZRS = 140
T = 62.13
num_points = 500

# Calculate the sagitta with the correct sign
def sag(r):
    numerator = -c * r**2  # Concave surface
    denominator = 1 + math.sqrt(1 - (1 + k)*c**2*r**2)
    return numerator / denominator

# Calculate the maximum radius
r_max = D/2

# Generate the 2D profile points
profile_points = []
for i in range(num_points+1):
    x = -r_max + 2*r_max*i/num_points
    r = abs(x)
    z = sag(r)
    profile_points.append(Base.Vector(x, 0, z))

# Create a wire from the profile points
wire = Part.makePolygon(profile_points)

# Check if wire is closed and valid
if not wire.isClosed():
    wire = wire.close()

# Create a face from the wire
face = Part.Face(wire)

# Revolve the face around the optical axis (Y-axis)
try:
    asphere = face.revolve(Base.Vector(0, 0, 0), Base.Vector(0, 1, 0), 360)
except Exception as e:
    print("Revolve operation failed:", e)
    # Alternative: revolve the wire instead of face
    try:
        revolved_wire = wire.revolve(Base.Vector(0, 0, 0), Base.Vector(0, 1, 0), 360)
        asphere = Part.Face(revolved_wire)
    except Exception as e2:
        print("Revolving wire also failed:", e2)
        # Handle error or abort
        asphere = None

# Proceed only if asphere is valid
if asphere:
    # Apply transformation for off-axis displacement and tilt
    theta = math.asin(ZRS / r_max)
    rotation = Base.Rotation(Base.Vector(0, 1, 0), math.degrees(theta))
    translation = Base.Vector(ZRS * math.cos(theta), 0, ZRS * math.sin(theta))
    transform = rotation.toMatrix()
    transform.move(translation)
    asphere = asphere.transformGeometry(transform)

    # Create the lateral cylinder
    cyl_dir = Base.Vector(math.cos(theta), 0, math.sin(theta))
    cylinder = Part.makeCylinder(D/2, T, translation, cyl_dir)

    # Intersect the aspheric surface with the cylinder
    mirror_body = cylinder.common(asphere)

    # Create rear plane surface
    rear_plane = Part.makePlane(D, D, translation + cyl_dir*T, cyl_dir)
    complete_mirror = mirror_body.fuse(rear_plane)

    # Show the result
    Part.show(complete_mirror)
    App.ActiveDocument.recompute()
else:
    print("Failed to generate the optical surface.")
