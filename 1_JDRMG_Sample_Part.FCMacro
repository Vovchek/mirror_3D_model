import FreeCAD, Part, math
from FreeCAD import Base

show_features = True # show all cut-off features - crown, pockets, notches, etc
slice_dirZ = FreeCAD.Vector(0, 1, 0) 
slice_size = 1000
slice_position = FreeCAD.Vector(-slice_size/2.0, 0, -slice_size/2.0)

# ========== Surface and Part Parameters ==========
c = 1/773.44    # Curvature [mm⁻¹]
k = -1.0504     # Conic constant
D = 276.41      # Mirror diameter [mm]
ZR = 140.0      # ZR in Optical Reference Frame (ORF)
ZRC = 142.0
T = 62.13       # Mirror thickness [mm]
Tc = 50.0		# Mirror center thickness [mm]
num_points = 500 # Increased resolution
R_bfs = 799.5   # Best Fit Sphere radius [mm]

def sag(r):
    numerator = c * r**2  # Negative for concave
    denominator = 1 + math.sqrt(1 - (1 + k)*c**2*r**2)
    return numerator / denominator

# ========== Calculate True OAA (θ) ==========
DX = 272 # picked-up value
r1 = ZR - DX/2
r2 = ZR + DX/2
z1 = sag(r1)
z2 = sag(r2)
z0 = sag(ZRC)
theta = math.atan((z2 - z1)/DX)  # angle calculation

# Outer lowering
crown_D = 246.4      # Rear crown diameter
crown_h = 53         # Crown height
n_flats = 12
crown_flat_d = 242.41  # Distance between opposite flats

# ========== Pockets' Parameters ==========
pocket_thickness = 6    # Material thickness [mm]
fillet_vertical = 6     # Vertical edge fillet radius [mm]
fillet_ceiling = 2      # Ceiling edge fillet radius [mm]
safety_margin = 10      # Extra extrusion margin [mm]


# lateral througt holes
D_lat_hole = 7
T_wall = 6 + 4 # +4 to make sure drill through
H_lat_hole = -Tc + 36.73
lat_hole_angles = [150, 60, 300]
lat_hole_shifts = [FreeCAD.Vector(6, 10.39, 0),
                   FreeCAD.Vector(10.39, -6, 0),
                   FreeCAD.Vector(-10.39, -6, 0)]

def mirror_shape_about_plane(shape, angle_deg, plane_point=Base.Vector(0,0,0)):
    """
    Mirrors a shape about a plane containing the OZ axis and making angle_deg with OX axis.
    :param shape: The FreeCAD shape to mirror (e.g., Part.Shape, Part.Solid, etc.)
    :param angle_deg: Angle (degrees) between OX and the plane (counterclockwise in XOY)
    :param plane_point: A point on the mirror plane (default: origin)
    :return: Mirrored shape (new object)
    """
    # Compute normal vector for the plane
    angle_rad = math.radians(angle_deg)
    # The plane's normal is perpendicular to the plane; for a plane containing OZ and at angle with OX,
    # the normal is in the XOY plane, at angle + 90° from OX.
    normal = Base.Vector(math.sin(angle_rad), -math.cos(angle_rad), 0)  # normal in XOY
    # Mirror the shape
    mirrored = shape.mirror(plane_point, normal)
    return mirrored

# Build profile points (in OXZ)
points = []

for i in range(num_points+1):
    x = r1 + i*(D/num_points)
    z = sag(abs(x))
    points.append(Base.Vector(x, 0, z))

# Add points for the rear and base to close the profile
# 1. From last asphere point, down lower then rear face
points.append(Base.Vector( r2+(T+z2)*math.tan(theta), 0, -T ))   # Rear bottom right
points.append(Base.Vector( r1, 0, -T ))  # Rear bottom left
points.append(points[0])  # Back to start

# Create the wire and face
wire = Part.makePolygon(points)
face = Part.Face(wire)

# Test face validity
if not face.isValid():
    raise ValueError("Face is not valid. Check the profile points.")

# Now you can revolve safely
asphere = face.revolve(Base.Vector(0,0,0), Base.Vector(0,0,1), 360)

# ========== Coordinate System Transformation ==========
z0s = z0*math.cos(theta) - ZRC*math.sin(theta)
x0s = ZRC*math.cos(theta) + z0*math.sin(theta)

print(f"z1s: {z1*math.cos(theta) - r1*math.sin(theta)} z2s: {z2*math.cos(theta) - r2*math.sin(theta)}")

rotation = Base.Rotation(Base.Vector(0,1,0), math.degrees(theta))
translation = Base.Vector(-x0s, 0, -z0s)

mat = rotation.toMatrix()
mat.move(translation)
asphere = asphere.transformGeometry(mat)

# ========== Lateral and Rear Surfaces Creation ==========
cylinder = Part.makeCylinder(D/2, 2*T, FreeCAD.Vector(0, 0, -Tc))

mirror_body = cylinder.common(asphere)
if show_features:
    Part.show(mirror_body, "blank")

# Rear face is at z = -Tc (assuming upper face at z=0)
base_z = -Tc     # Start of the ring at the rear
ring_height = crown_h

# Create outer cylinder (full diameter)
outer_cyl = Part.makeCylinder(D/2, ring_height, FreeCAD.Vector(0, 0, base_z))
# Create inner cylinder (crown diameter)
inner_cyl = Part.makeCylinder(crown_D/2, ring_height, FreeCAD.Vector(0, 0, base_z))

# The ring to remove is the difference between the two cylinders
ring_to_remove = outer_cyl.cut(inner_cyl)

# Subtract this ring from the mirror body
mirror_hat = mirror_body.cut(ring_to_remove)

# Build dodecagon (12-sided polygon) in XOY, centered at (0,0)
radius = crown_flat_d / (2 * math.cos(math.pi/n_flats))  # Circumradius 

points = []
for i in range(n_flats):
    angle = 2 * math.pi * (i + 0.5) / n_flats
    x = radius * math.cos(angle)
    y = radius * math.sin(angle)
    points.append(FreeCAD.Vector(x, y, base_z))

# Close the polygon
points.append(points[0])

# Make wire and face
wire = Part.makePolygon(points)
face = Part.Face(wire)

# Extrude the face to make the crown solid
crown_poly = face.extrude(FreeCAD.Vector(0, 0, crown_h))

# Make notches
notch_depth = 1.0   # mm, how deep into the flat
notch_height = 20.0 # mm, how high along Z
notch_x = crown_flat_d / 2.0

p0 = Base.Vector(notch_x, -notch_depth, base_z)
p1 = Base.Vector(notch_x, notch_depth, base_z)
p2 = Base.Vector(notch_x - notch_depth, 0, base_z)

# Build triangle at base_z
tri_base = [p0, p1, p2, p0]

# Extrude up along Z
tri_wire = Part.makePolygon(tri_base)
tri_face = Part.Face(tri_wire)
notch_prism = tri_face.extrude(Base.Vector(0, 0, notch_height))
if show_features:
    Part.show(notch_prism, "upper_notch")

# Subtract notch from crown_poly (or mirror_hat, as needed)
crown_poly = crown_poly.cut(notch_prism)

# Oposite notch
notch_prism = mirror_shape_about_plane(notch_prism, 90)
if show_features:
    Part.show(notch_prism, "vertex_notch")
crown_poly = crown_poly.cut(notch_prism)

# Now make the outer cylinder as before
outer_cyl = Part.makeCylinder(D/2, crown_h, FreeCAD.Vector(0, 0, base_z))

# The ring to remove is the difference between the outer cylinder and the dodecagon
ring_to_remove = outer_cyl.cut(crown_poly)
if show_features:
    Part.show(ring_to_remove, "crown")

# Subtract this ring from the mirror body
mirror_hat = mirror_hat.cut(ring_to_remove)

#================================= Pockets ===============================


# ========== Create Pocket Template ==========

def create_triangular_prism(edge_length, side_center, direction, height, safety_margin=10, fillet_radius=6):
    import FreeCAD, Part, math
    from FreeCAD import Base

    # Calculate triangle vertices
    # 1. Find endpoints of the base side
    perp = direction.cross(Base.Vector(0,0,1))  # Perpendicular in XOY
    perp.normalize()
    half_side = edge_length / 2
    p1 = side_center + perp * half_side
    p2 = side_center - perp * half_side

    # 2. Find the opposite vertex
    # The centroid divides the median in a 2:1 ratio from vertex to side
    # For equilateral, distance from side to opposite vertex: h = edge_length * sqrt(3)/2
    h = edge_length * math.sqrt(3) / 2
    p3 = side_center + direction * h

    # 3. Place all points at the same Z (use safety_margin above mirror, extrude downward)
    z0 = safety_margin
    p1 = Base.Vector(p1.x, p1.y, z0)
    p2 = Base.Vector(p2.x, p2.y, z0)
    p3 = Base.Vector(p3.x, p3.y, z0)

    # Create wire and face
    wire = Part.makePolygon([p1, p2, p3, p1])
    face = Part.Face(wire)

    # Extrude downward
    prism = face.extrude(Base.Vector(0, 0, -height))

    # Fillet vertical edges
    vertical_edges = []
    for edge in prism.Edges:
        v1, v2 = edge.Vertexes
        if abs(v1.Point.x - v2.Point.x) < 1e-6 and abs(v1.Point.y - v2.Point.y) < 1e-6:
            vertical_edges.append(edge)
        elif abs(edge.tangentAt(0).z) > 0.99:
            vertical_edges.append(edge)
    if vertical_edges:
        prism = prism.makeFillet(fillet_radius, vertical_edges)

    return prism

# ========== Create Spherical Ceiling ==========
def create_ceiling_sphere(R_bfs, pocket_thickness):
    R_ceiling = R_bfs + pocket_thickness
    sphere = Part.makeSphere(R_ceiling, Base.Vector(0,0,R_bfs), Base.Vector(0,0,1), -90, -60, 360)
    return sphere

ceiling = create_ceiling_sphere(R_bfs, pocket_thickness)

# ========== Main Pocket Creation ==========
def create_pocket(edge_length, side_center, direction, height, ceiling, fillet_vertical=6):
    prism = create_triangular_prism(edge_length, side_center, direction, height, fillet_radius=fillet_vertical)
    pocket = prism.cut(ceiling)
    return pocket

def angle_between(v1, v2):
    if v1.Length == 0 or v2.Length == 0:
        print("Warning: Zero-length vector in angle calculation.")
        return 0
    dot = v1.normalize().dot(v2.normalize())
    dot = max(min(dot, 1.0), -1.0)
    return math.degrees(math.acos(dot))

def remove_consecutive_duplicates(points):
    new_points = []
    for p in points:
        if not new_points or (p - new_points[-1]).Length > 1e-6:
            new_points.append(p)
    return new_points

def create_polygonal_prism(points, height, safety_margin=10, fillet_radius=6):
    base_points = remove_consecutive_duplicates([Base.Vector(p.x, p.y, safety_margin) for p in points])
    # Raise all points to the same Z (safety_margin above surface)
    base_points = [Base.Vector(p.x, p.y, safety_margin) for p in points]
    # Close the polygon
    if base_points[0] != base_points[-1]:
        base_points.append(base_points[0])
    wire = Part.makePolygon(base_points)
    face = Part.Face(wire)
    # Extrude downward
    prism = face.extrude(Base.Vector(0, 0, -height))

    # Find vertical edges with internal angle < 120 deg
    vertical_edges = []
    n = len(points)
    for i, edge in enumerate(prism.Edges):
        v1, v2 = edge.Vertexes
        # Check if edge is vertical (X, Y unchanged, Z changes)
        if (abs(v1.Point.x - v2.Point.x) < 1e-6 and
            abs(v1.Point.y - v2.Point.y) < 1e-6 and
            abs(v1.Point.z - v2.Point.z) > 1e-6):
            # Find previous and next base points for angle calculation
            idx = None
            for j, p in enumerate(base_points[:-1]):
                if abs(p.x - v1.Point.x) < 1e-6 and abs(p.y - v1.Point.y) < 1e-6:
                    idx = j
                    break
            if idx is not None:
                prev = base_points[idx - 1]
                curr = base_points[idx]
                next = base_points[(idx + 1) % n]
                v_prev = curr.sub(prev)
                v_next = next.sub(curr)
                angle = angle_between(v_prev, v_next)
                if angle < 120:
                    vertical_edges.append(edge)
    # Apply fillet if any
    if vertical_edges:
        prism = prism.makeFillet(fillet_radius, vertical_edges)
    return prism

def create_polygonal_pocket(points, height, ceiling, safety_margin=10, fillet_radius=6):
    prism = create_polygonal_prism(points, height, safety_margin, fillet_radius)
    pocket = prism.cut(ceiling)
    return pocket

final_mirror = mirror_hat

# ========== Create 3 small triangular Pockets ==========
edge_length = 62.5      # Triangle side length [mm]
radial_pos = 115.2      # Distance from center to nearest vertex [mm]
angles = (0, 120, 240)  # 0°, 120°, 240°

pocket = create_pocket(edge_length, Base.Vector(radial_pos, 0, 0), Base.Vector(-1, 0, 0), Tc+2*safety_margin, ceiling)
if show_features:
	Part.show(pocket, "small_3a_pocket_0")
final_mirror = final_mirror.cut(pocket)

pocket.rotate(Base.Vector(0,0,0), Base.Vector(0,0,1), 120)
if show_features:
	Part.show(pocket, "small_3a_pocket_120")
final_mirror = final_mirror.cut(pocket)

pocket.rotate(Base.Vector(0,0,0), Base.Vector(0,0,1), 120)
if show_features:
	Part.show(pocket, "small_3a_pocket_240")
final_mirror = final_mirror.cut(pocket)

# ========== Create 3 bigger triangular Pockets ==========
edge_length = 85      # Triangle side length [mm]
radial_pos = -30.5      # Distance from center to nearest vertex [mm]
angles = (0, 120, 240)  # 0°, 120°, 240°

pocket = create_pocket(edge_length, Base.Vector(radial_pos, 0, 0), Base.Vector(-1, 0, 0), Tc+2*safety_margin, ceiling)
if show_features:
	Part.show(pocket, "big_3a_pocket_0")
final_mirror = final_mirror.cut(pocket)

pocket.rotate(Base.Vector(0,0,0), Base.Vector(0,0,1), 120)
if show_features:
	Part.show(pocket, "big_3a_pocket_120")
final_mirror = final_mirror.cut(pocket)

pocket.rotate(Base.Vector(0,0,0), Base.Vector(0,0,1), 120)
if show_features:
	Part.show(pocket, "big_3a_pocket_240")
final_mirror = final_mirror.cut(pocket)

# ========== Create 1 center triangular Pocket ==========
radial_pos = -24.5      # Distance from center to nearest vertex [mm]
pocket = create_pocket(edge_length, Base.Vector(radial_pos, 0, 0), Base.Vector(1, 0, 0), Tc+2*safety_margin, ceiling)
if show_features:
	Part.show(pocket, "big_3a_pocket_center")
final_mirror = final_mirror.cut(pocket)

# ========== Create Polygonal Pockets ==========
polygon_points = [
    Base.Vector(58, 5, 0),
    Base.Vector(58, 99, 0),
    Base.Vector(76, 89, 0),
    Base.Vector(89, 76, 0),
    Base.Vector(112.5, 35.8, 0),
]

height = Tc + 2*safety_margin  # Use your mirror thickness and margin
# Assume 'ceiling' is already defined (e.g., a sphere as before)

pocket = create_polygonal_pocket(polygon_points, height, ceiling)
if show_features:
    Part.show(pocket, "poly_pocket_1")
final_mirror = final_mirror.cut(pocket)

pocket = mirror_shape_about_plane(pocket, 0)
if show_features:
    Part.show(pocket, "poly_pocket_2")
final_mirror = final_mirror.cut(pocket)

pocket = mirror_shape_about_plane(pocket, -60)
if show_features:
    Part.show(pocket, "poly_pocket_3")
final_mirror = final_mirror.cut(pocket)

pocket = mirror_shape_about_plane(pocket, 60)
if show_features:
    Part.show(pocket, "poly_pocket_4")
final_mirror = final_mirror.cut(pocket)

pocket = mirror_shape_about_plane(pocket, 0)
if show_features:
    Part.show(pocket, "poly_pocket_5")
final_mirror = final_mirror.cut(pocket)

pocket = mirror_shape_about_plane(pocket, -60)
if show_features:
    Part.show(pocket, "poly_pocket_6")
final_mirror = final_mirror.cut(pocket)

# ========== Mounting holes ================
hole_diameter = 15
hole_position_x = 55

# Create cylindrical pocket (extruded circle)
# Place pocket top at safety margin above mirror surface (Z= safety_margin)
pocket_top_z = safety_margin
depth = Tc + 2 * safety_margin
pocket_base_z = pocket_top_z - depth

hole = Part.makeCylinder(hole_diameter/2.0, depth, Base.Vector(hole_position_x, 0, pocket_base_z))
hole = hole.cut(ceiling)

if show_features:
    Part.show(hole, "hole_0")
final_mirror = final_mirror.cut(hole)

hole.rotate(Base.Vector(0,0,0), Base.Vector(0,0,1), 120)
if show_features:
    Part.show(hole, "hole_120")
final_mirror = final_mirror.cut(hole)

hole.rotate(Base.Vector(0,0,0), Base.Vector(0,0,1), 120)
if show_features:
    Part.show(hole, "hole_240")
final_mirror = final_mirror.cut(hole)

# ========== Drill lateral holes ===========
for i in range(3):
    hole = Part.makeCylinder(D_lat_hole/2.0, T_wall, Base.Vector(crown_flat_d/2.0 + 1, 0, H_lat_hole), Base.Vector(-1, 0, 0))
    hole.rotate(Base.Vector(0,0,0), Base.Vector(0,0,1), lat_hole_angles[i])
    hole.translate(lat_hole_shifts[i])
    if show_features:
        Part.show(hole, f"lat_hole_{lat_hole_angles[i]}")
    final_mirror = final_mirror.cut(hole)

# ========== Finalize and Display ==========

Part.show(final_mirror, "MirrorWithPockets")

#================================= Section to check geometry ===============================
def create_section(body, slice_size, slice_position, slice_dirZ):
    if slice_size <= 0:
	    return None
    # If mirror_body is a Compound, extract its solids
    solids = [s for s in body.Solids]

# Create the XOZ plane as before
    slice_plane = Part.makePlane(slice_size, slice_size, slice_position, slice_dirZ)

# Section each solid in the compound
    sections = []
    for solid in solids:
        section = solid.section(slice_plane)
        if not section.isNull():
            sections.append(section)

    if sections:  # Only if the list is not empty
        compound_section = Part.Compound(sections)
        return compound_section
    
section = create_section(final_mirror, slice_size, slice_position, slice_dirZ)
if not (section is None):
    Part.show(section, "section")

App.ActiveDocument.recompute()
